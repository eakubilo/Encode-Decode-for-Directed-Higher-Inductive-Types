\documentclass[main.tex]{subfiles}
\begin{document}
\subsection{Introduction}
In type theory, the basic object of study is the type. Sitting at the lowest level, we can specify types whose \textit{points} are freely generated by a list of constructors - these types are aptly named \textit{inductive types}. From these inductive types, we can form sections to come to the notion of dependent products, or we can ask what type they live in to arrive at universes. We can also extend the notion of the inductive types themselves, allowing constructors to specify \textit{paths} in the type, not just points to get \textit{higher inductive types}. In a directed setting, the notion of a \textit{directed} higher inductive type should correspond to the notion of a \textit{category} (with some extra work). That is, certain directed higher inductive definitions of types satisfy the \textit{Segal} property.

\subsection{Unit}
We begin by defining the type Unit, which only has one constructor:
\begin{itemize}
    \item $\star\,: \ $Unit
\end{itemize}
Abstractly, this should be the type generated by a single point. By definition, we can always form the morphism $\id{\star} : \ho[\text{Unit}]{\star}{\star}$. We expect, though, for there to be no more information than we put into the type. So, the identity should be the only morphism of the unit type.
\begin{lemma} For all $ \normalfont f : \ho[\text{Unit}]{\star}{\star}$,
\[ f = \id{\star}\]
\end{lemma}
\begin{proof}
For all $x : \mathbbm{2}$, we have that $f(x) = \star = \id{\star}(x)$. By functional extensionality, $f = \id{\star}$.
\end{proof}
The unit type corresponds to the category with one object and one morphism (the identity).
\subsection{I}
The free category with a arrow $I$, is generated by the following constructors.
\begin{itemize}
    \item $0_I$
    \item $1_I$
    \item $\seg : \ho[I]{0_I}{1_I}$
    \item $\text{is-segal}(I)$
\end{itemize}
We then check that the positive description of the type is enough to ensure that the type actually models the free category with an arrow. To start, we check that the only morphisms starting from $0_I$ are the identity morphism and $\seg$.
\begin{lemma}
\[
\prod_{x:I}\ho[I]{0_I}{x}\text{ \emph{is contractible}}
\]
\end{lemma}
\begin{proof}
    By Lemma 3.11.6 in HoTT book, it suffices to show that each fiber of $\lambda x. \ho[I]{0_I}{x}$ is contractible. So, we first define a map $$\text{center} : \displaystyle \prod_{x:I}\ho[I]{0_I}{x}.$$
    which gives the center of contraction for each fiber as follows:
    \begin{align*}
        &center(0_I) = \id{0_I}\\
        &center(1_I) = \seg\\
        &center(\seg) = \land_\seg
    \end{align*}
    It then suffices to inhabit the type
    $$\prod_{x:I}\prod_{f:\ho[I]{0_I}{x}}f=\text{center}(x).$$
    Since $\lambda x.\ho[I]{0_I}{x}$ is covariant, by lemma 8.26, $$\lambda x. \lambda f.f = \text{center}(x):\displaystyle \prod_{x:I}(\ho[I]{0_I}{x} \to \mathcal{U})$$
    is also covariant. Thus, by  theorem 9.5 of Riehl Shulman, (the dependent yoneda lemma), to exhibit such a type we can give an inhabitant of $\id{0_I}=\text{center}(0_I) \equiv \id{0_I}$, of which $\refl{\id{0_I}}$ suffices.
\end{proof}
We can similarly characterize the morphisms ending at $1_I$. 
\begin{lemma}
\[
\prod_{x:I}\ho[I]{x}{1_I}\text{ \emph{is contractible}}
\]
\end{lemma}
\begin{proof}
    Just as in Lemma 2, we define a map $$\text{center} : \displaystyle \prod_{x:I}\ho[I]{x}{1_I}.$$
    which gives the center of contraction for each fiber as follows:
    \begin{align*}
        &center(0_I) = \seg\\
        &center(1_I) = \id{1_I}\\
        &center(\seg) = \lor_\seg
    \end{align*}
    It then suffices to inhabit the type
    $$\prod_{x:I}\prod_{q:\ho[I]{1_I}{x}}q=\text{center}(x).$$
    Because of the equivalence from theorem 9.5 of Riehl Shulman, (the dependent yoneda lemma), to exhibit such a type we can give an inhabitant of $\id{1_I}=\text{center}(1_I) \equiv \id{1_I}$, of which $\refl{\id{1_I}}$ suffices.
\end{proof}

%Assuming one the existence of one particular type family allows us to characterize such morphisms.
% \begin{lemma}
%     The type family $$\emph{code} : I \to \mathcal{U_{\emph{cov}}}$$
%     \begin{align*}
%         &\emph{code}(0_I) = \emph{void}\\
%         &\emph{code}(1_I) = \emph{Unit}\\
%     \end{align*}
%     is covariant.
% \end{lemma}
% \begin{proof}
%     To show that $\text{code}$ is a covariant type family, we first start by showing it has
% \end{proof}
\begin{lemma}
    Given a covariant type family $$\emph{code} : I \to \mathcal{U_{\emph{cov}}}$$
    defined as
    \begin{align*}
        &\emph{code}(0_I) = \emph{void}\\
        &\emph{code}(1_I) = \emph{Unit}\\
        &\emph{code}(\emph{\seg}) = \emph{duahom(!)}
    \end{align*}
    then
    $$\prod_{x:I}\ho[I]{1_I}{x}\cong \emph{code}(x)$$
\end{lemma}
\begin{proof}
    By prop 9.10 of RS17, it suffices to show that the type  $$\sum_{x:I}\text{code}(x)$$ 
    has an initial element $(1_I, \star)$. We do so by defining a map
    $$\phi:\prod_{(a,u):\sum_{x:I}\text{code}(x)}\ho[\sum_{x:I}\text{code}(x)]{(1_I,\star)}{(a,u)} \text{ is contractible}$$
    By $\prod$-induction, we first consider $(0_I, u)$. Since $u : \text{void}$, we can simply return abort(u). For the pair $(1_I, \star)$, note that $\ho[\text{Unit}]{\star}{\star}$ is contractible by lemma 1. So, it suffices to show that $\ho[I]{1_I}{1_I}$ is contractible. Thus, we need to form an inhabitant of the type
    $$\sum_{g : \ho[I]{1_I}{1_I}}\prod_{f : \ho[I]{1_I}{1_I}} g=_{\ho[I]{1_I}{1_I}}f$$
    Taking $\id{1_I}$ as the center of contraction, let $f: \ho[I]{1_I}{1_I}$. We need an inhabitant of the type $$\id{1_I} =_{\ho[I]{1_I}{1_I}} f.$$
    Since $I$ is Segal, by prop 5.10 of RS17, we can alternatively supply a point of the type $$\homtwo{I}(1_I,1_I,1_I,\id{1_I},\id{1_I}, f).$$
    By prop 5.5 of RS17, this reduces to supplying a point of the type \[ \ndexten{\sh{\langle t,s \rangle:I \times J}{\Lambda^2_1}}{I}{\Lambda^2_1}{[1_I, 1_I, 1_I, \id{1_I}, \id{1_I}]}, \]
    of which $\lambda\langle t, s \rangle.1_I$ suffices. Thus, $(1_I, \star)$ is initial as claimed, so code is a representable type family.

\end{proof}
\end{document}
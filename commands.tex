\newcommand{\id}[1]{\mathsf{id}_{#1}}
\newcommand{\idhom}[1]{\mathsf{idhom}_{#1}}
\newcommand{\refl}[1]{\mathsf{refl}_{#1}}
\newcommand{\Un}{\mathsf{Unit}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Ns}{\mathbb{N}^s}
\newcommand{\Nd}{\mathbb{N}^d}
\newcommand{\ba}{\mathsf{base}}
\newcommand{\dl}{\mathsf{dloop}}
\newcommand{\mon}{\mathsf{monoid}}
\newcommand{\assoc}{\mathsf{associativity}}
\newcommand{\iden}{\mathsf{identity}}
\newcommand{\Li}[1]{\mathsf{List}\,#1}
\newcommand{\nil}{\mathsf{nil}}
\newcommand{\cons}[2]{\mathsf{cons}({#1},{#2})}
\newcommand{\add}{\mathsf{sum}}
\newcommand{\recOr}[3]{\mathsf{rec}_{\lor}^{#1}(#2, #3)}

\newcommand{\sSet}{\mathsf{sSet}}
\newcommand{\ssSet}{\mathsf{ssSet}}

\newcommand{\vo}{\mathsf{Void}}
\newcommand{\uc}{\U_\mathsf{cov}}
\newcommand{\isc}{ \mathsf{isCovAriant}}
\newcommand{\isd}{ \mathsf{isDiscrete}}
\newcommand{\El}{ \mathsf{El}}
\newcommand{\dua}{\mathsf{dua}}
\newcommand{\dcoe}{\mathsf{dcoe}}
\newcommand{\ho}[3][]{\mathsf{hom}_{#1}(#2,#3)}
\newcommand{\dho}[4]{\normalfont  \hom_{#1(#2)}(#3, #4)}
\newcommand{\dhot}[5]{\normalfont  \hom^2_{#1(#2)}(#3, #4; #5)}
\newcommand{\hot}[4][]{\ensuremath{\mathsf{hom}^2_{#1}({#2},{#3};{#4})}}
\newcommand{\seg}{\mathsf{seg}}
\newcommand{\defeq}{\vcentcolon\equiv}
\newcommand{\comp}[2]{\mathsf{comp}_{#1, #2}}
\newcommand{\co}{\mathsf{code}}
\newcommand{\eco}{\mathsf{encode}}
\newcommand{\fst}{\mathsf{fst}}
\newcommand{\snd}{\mathsf{snd}}
\newcommand{\dco}{\mathsf{decode}}
\newcommand{\htf}{ \mathsf{homtofun}}
\newcommand{\ida}{\mathsf{idtoarr}}
\newcommand{\idi}{\mathsf{idtoiso}}
\newcommand{\ide}{\mathsf{idtoequiv}}
\newcommand{\funext}{\normalfont \mathsf{funext}}
\newcommand{\happly}{\normalfont \mathsf{happly}}
\newcommand{\cu}{\normalfont \mathsf{cube}}
\newcommand{\tope}{\normalfont \mathsf{tope}}
\newcommand{\dom}{\normalfont \mathsf{dom}}
\newcommand{\cod}{\normalfont \mathsf{cod}}
\newcommand{\two}{\mathbb{2}}
\newcommand{\yon}[2]{\normalfont \mathsf{yon}^{#1}_{#2}}
\newcommand{\evid}[2]{\normalfont \mathsf{evid}^{#1}_{#2}}
\newcommand{\trans}[2]{\mathsf{trans}_{{#1}, {#2}}}
\newcommand{\qinv}{\normalfont \mathsf{qinv}}
\newcommand{\linv}{\normalfont \mathsf{linv}}
\newcommand{\rinv}{\normalfont \mathsf{rinv}}
\newcommand{\biinv}{\normalfont \mathsf{biinv}}
\newcommand{\iseq}{\normalfont \mathsf{isequiv}}
\newcommand{\tot}{\normalfont \mathsf{total}}
\newcommand{\preshape}[3]{\ensuremath{\nobreak{#1}\nobreak : \nobreak {#2}\,\mid\,{#3}\nobreak}}
\newcommand{\shape}[3]{\ensuremath{\{\preshape{{#1}}{{#2}}{{#3}}\} }}
\newcommand{\recbot}{\normalfont \mathsf{rec}_\bot}
%from RS17
\newcommand{\sh}[2]{\{#1\mid #2\}}
\newcommand{\exten}[4]{\left\langle\mathchoice{\textstyle\prod_{#1}}{\textstyle\prod_{#1}}{\scriptstyle\prod_{#1}}{\scriptscriptstyle\prod_{#1}} #2 \middle|^{#3}_{#4}\right\rangle}
\newcommand{\ndexten}[4]{\left\langle #1 \to #2 \middle|^{#3}_{#4}\right\rangle}
\newcommand{\tw}{\mathbbm{2}}
\newcommand{\cube}{\mathsf{cube}}
\newcommand{\dtran}[1]{\mathsf{dtransport}^{#1}}
\newcommand{\iso}{\mathsf{isiso}}
\newcommand{\su}{\mathsf{succ}}

%extension type stuff
\def\pair#1#2{\left \langle #1, #2 \right \rangle}

%simplex stuff
\def\tzhorn{\Lambda_0^2}
\def\tohorn{\Lambda_1^2}
\def\tthorn{\Lambda_2^2}
\def\pardo{\partial\Delta^1}
\def\pardt{\partial\Delta^2}
\def\pards{\partial\square}
\def\osx{\Delta^1}

\def\tsx{\Delta^2}

\def\diagshort#1(#2,#3,#4,#5,#6,#7,#8,#9){\mathsf{diag}_{#1}^2(#6,#7;#8,#9)}
\def\diag#1{\mathsf{diag}_{#1}^2\diagarg1}
\def\diaglong#1#2{\mathsf{diag}_{#2}^2\diagarg#1}
\def\diagarg#1(#2,#3,#4,#5,#6,#7,#8,#9){%
\left(
\vcenter{\hbox{\begin{tikzpicture}[xscale=#1]
      \node (a) at (0,0) {$\scriptstyle #2$};
      \node (b) at (2,0) {$\scriptstyle #3$};
      \node (c) at (2,2) {$\scriptstyle #4$};
      \node (d) at (0,2) {$\scriptstyle #5$};

      \draw (a) -- node [auto] {$\scriptstyle #6$} (d);
      \draw (d) -- node [auto] {$\scriptstyle #7$} (c);
      \draw (a) -- node [auto,swap] {$\scriptstyle #8$} (b);
      \draw (b) -- node [auto,swap] {$\scriptstyle #9$} (c);
    \end{tikzpicture}}}
  \right)}
\def\homtwoshort#1(#2,#3,#4,#5,#6,#7){\hom_{#1}^2(#5,#6;#7)}
\def\homtwo#1{\hom_{#1}^2\homtwoarg1}
\def\homtwolong#1#2{\hom_{#2}^2\homtwoarg#1}
\def\homtwoarg#1(#2,#3,#4,#5,#6,#7){\left(
    \begin{tikzpicture}[baseline,xscale=#1]
      \node (a) at (0,0) {$\scriptstyle #2$};
      \node (b) at (1,.3) {$\scriptstyle #3$};
      \node (c) at (2,0) {$\scriptstyle #4$};
      \draw (a) -- node [auto] {$\scriptstyle #5$} (b);
      \draw (b) -- node [auto] {$\scriptstyle #6$} (c);
      \draw (a) -- node [auto,swap] {$\scriptstyle #7$} (c);
    \end{tikzpicture}\right)}


%https://tex.stackexchange.com/questions/325297/how-to-scale-a-tikzcd-diagram


%%book hott%%

%%% Dependent products %%%
\def\prdsym{\textstyle\prod}
%% Call the macro like \prd{x,y:A}{p:x=y} with any number of
%% arguments.  Make sure that whatever comes *after* the call doesn't
%% begin with an open-brace, or it will be parsed as another argument.
\makeatletter
% Currently the macro is configured to produce
%     {\textstyle\prod}(x:A) \; {\textstyle\prod}(y:B),{\ }
% in display-math mode, and
%     \prod_{(x:A)} \prod_{y:B}
% in text-math mode.
% \def\prd#1{\@ifnextchar\bgroup{\prd@parens{#1}}{%
%     \@ifnextchar\sm{\prd@parens{#1}\@eatsm}{%
%         \prd@noparens{#1}}}}
\def\prd#1{\@ifnextchar\bgroup{\prd@parens{#1}}{%
    \@ifnextchar\sm{\prd@parens{#1}\@eatsm}{%
    \@ifnextchar\prd{\prd@parens{#1}\@eatprd}{%
    \@ifnextchar\;{\prd@parens{#1}\@eatsemicolonspace}{%
    \@ifnextchar\\{\prd@parens{#1}\@eatlinebreak}{%
    \@ifnextchar\narrowbreak{\prd@parens{#1}\@eatnarrowbreak}{%
      \prd@noparens{#1}}}}}}}}
\def\prd@parens#1{\@ifnextchar\bgroup%
  {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}\prd@parens}%
  {\@ifnextchar\sm%
    {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}\@eatsm}%
    {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}}}}
\def\@eatsm\sm{\sm@parens}
\def\prd@noparens#1{\mathchoice{\@dprd@noparens{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}}
% Helper macros for three styles
\def\lprd#1{\@ifnextchar\bgroup{\@lprd{#1}\lprd}{\@@lprd{#1}}}
\def\@lprd#1{\mathchoice{{\textstyle\prod}}{\prod}{\prod}{\prod}({\textstyle #1})\;}
\def\@@lprd#1{\mathchoice{{\textstyle\prod}}{\prod}{\prod}{\prod}({\textstyle #1}),\ }
\def\tprd#1{\@tprd{#1}\@ifnextchar\bgroup{\tprd}{}}
\def\@tprd#1{\mathchoice{{\textstyle\prod_{(#1)}}}{\prod_{(#1)}}{\prod_{(#1)}}{\prod_{(#1)}}}
\def\dprd#1{\@dprd{#1}\@ifnextchar\bgroup{\dprd}{}}
\def\@dprd#1{\prod_{(#1)}\,}
\def\@dprd@noparens#1{\prod_{#1}\,}

%%% Dependent sums %%%
\def\smsym{\textstyle\sum}
% Use in the same way as \prd
\def\sm#1{\@ifnextchar\bgroup{\sm@parens{#1}}{%
    \@ifnextchar\prd{\sm@parens{#1}\@eatprd}{%
    \@ifnextchar\sm{\sm@parens{#1}\@eatsm}{%
    \@ifnextchar\;{\sm@parens{#1}\@eatsemicolonspace}{%
    \@ifnextchar\\{\sm@parens{#1}\@eatlinebreak}{%
    \@ifnextchar\narrowbreak{\sm@parens{#1}\@eatnarrowbreak}{%
        \sm@noparens{#1}}}}}}}}
\def\sm@parens#1{\@ifnextchar\bgroup%
  {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}\sm@parens}%
  {\@ifnextchar\prd%
    {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}\@eatprd}%
    {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}}}}
\def\@eatprd\prd{\prd@parens}
\def\sm@noparens#1{\mathchoice{\@dsm@noparens{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}}
\def\lsm#1{\@ifnextchar\bgroup{\@lsm{#1}\lsm}{\@@lsm{#1}}}
\def\@lsm#1{\mathchoice{{\textstyle\sum}}{\sum}{\sum}{\sum}({\textstyle #1})\;}
\def\@@lsm#1{\mathchoice{{\textstyle\sum}}{\sum}{\sum}{\sum}({\textstyle #1}),\ }
\def\tsm#1{\@tsm{#1}\@ifnextchar\bgroup{\tsm}{}}
\def\@tsm#1{\mathchoice{{\textstyle\sum_{(#1)}}}{\sum_{(#1)}}{\sum_{(#1)}}{\sum_{(#1)}}}
\def\dsm#1{\@dsm{#1}\@ifnextchar\bgroup{\dsm}{}}
\def\@dsm#1{\sum_{(#1)}\,}
\def\@dsm@noparens#1{\sum_{#1}\,}


%%% Map on paths %%%
\newcommand{\mapfunc}[1]{\ensuremath{\mathsf{map}_{#1}}\xspace} % Without argument
\newcommand{\map}[2]{\ensuremath{{#1}\mathopen{}\left({#2}\right)\mathclose{}}\xspace}
\let\Ap\map
%\newcommand{\Ap}[2]{\ensuremath{{#1}\left({#2}\right)}\xspace}
\newcommand{\mapdepfunc}[1]{\ensuremath{\mathsf{mapd}_{#1}}\xspace} % Without argument
% \newcommand{\mapdep}[2]{\ensuremath{{#1}\llparenthesis{#2}\rrparenthesis}\xspace}
\newcommand{\mapdep}[2]{\ensuremath{\mapdepfunc{#1}\mathopen{}\left(#2\right)\mathclose{}}\xspace}

%%% 2D map on paths
\newcommand{\aptwofunc}[1]{\ensuremath{\mathsf{ap}^2_{#1}}\xspace}
\newcommand{\aptwo}[2]{\ensuremath{\aptwofunc{#1}\mathopen{}\left({#2}\right)\mathclose{}}\xspace}
\newcommand{\apdtwofunc}[1]{\ensuremath{\mathsf{apd}^2_{#1}}\xspace}
\newcommand{\apdtwo}[2]{\ensuremath{\apdtwofunc{#1}\mathopen{}\left(#2\right)\mathclose{}}\xspace}

%%% Lambda abstractions.
% Each variable being abstracted over is a separate argument.  If
% there is more than one such argument, they *must* be enclosed in
% braces.  Arguments can be untyped, as in \lam{x}{y}, or typed with a
% colon, as in \lam{x:A}{y:B}. In the latter case, the colons are
% automatically noticed and (with current implementation) the space
% around the colon is reduced.  You can even give more than one variable
% the same type, as in \lam{x,y:A}.
\def\lam#1{{\lambda}\@lamarg#1:\@endlamarg\@ifnextchar\bgroup{.\,\lam}{.\,}}
\def\@lamarg#1:#2\@endlamarg{\if\relax\detokenize{#2}\relax #1\else\@lamvar{\@lameatcolon#2},#1\@endlamvar\fi}
\def\@lamvar#1,#2\@endlamvar{(#2\,{:}\,#1)}
% \def\@lamvar#1,#2{{#2}^{#1}\@ifnextchar,{.\,{\lambda}\@lamvar{#1}}{\let\@endlamvar\relax}}
\def\@lameatcolon#1:{#1}
\let\lamt\lam
% This version silently eats any typing annotation.
\def\lamu#1{{\lambda}\@lamuarg#1:\@endlamuarg\@ifnextchar\bgroup{.\,\lamu}{.\,}}
\def\@lamuarg#1:#2\@endlamuarg{#1}

% Function definition with domain and codomain
\newcommand{\function}[4]{\left\{\begin{array}{rcl}#1 &
      \longrightarrow & #2 \\ #3 & \longmapsto & #4 \end{array}\right.}



%%%shit i nabbed from book hott
%%% Map on morphisms %%%
\newcommand{\maparrfunc}[1]{\ensuremath{\mathsf{map}^{\rightarrow}_{#1}}\xspace} % Without argument
\newcommand{\maparr}[2]{\ensuremath{{#1}\mathopen{}\left({#2}\right)\mathclose{}}\xspace}
\let\ap\maparr

%%% 2D map on paths
\newcommand{\apatwofunc}[1]{\ensuremath{\mathsf{ap}^{2\rightarrow}_{#1}}\xspace}
% \newcommand{\aptwo}[2]{\ensuremath{\aptwofunc{#1}\mathopen{}\left({#2}\right)\mathclose{}}\xspace}
% \newcommand{\apdtwofunc}[1]{\ensuremath{\mathsf{apd}^2_{#1}}\xspace}
% \newcommand{\apdtwo}[2]{\ensuremath{\apdtwofunc{#1}\mathopen{}\left(#2\right)\mathclose{}}\xspace}

%%% Bracket/squash/truncation types %%%
\newcommand{\trunc}[2]{\mathopen{}\left\Vert #2\right\Vert_{#1}\mathclose{}}

%%% Equivalence types %%%
\newcommand{\hfib}[2]{{\mathsf{fib}}_{#1}(#2)}

%%% Map on paths %%%
\newcommand{\apfunc}[1]{\ensuremath{\mathsf{ap}_{#1}}\xspace} % Without argument

%% random

%https://tex.stackexchange.com/questions/273034/square-version-of-cdot-small-black-square
\newcommand*\sq{\mathbin{\vcenter{\hbox{\rule{.3ex}{.3ex}}}}}

